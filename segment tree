#include<bits/stdc++.h>
using namespace std;
#define int long long
#define fastio()ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)
#define MOD 1000000007
#define MOD1 998244353
#define pb push_back
#define ppb pop_back
#define mp make_pair
#define ff first
#define ss second
#define PI 3.141592653589793238462
#define set_bits __builtin_popcountint
#define sz(x)((int)(x).size())
#define all(x)(x).begin(),(x).end()
#define ffor(n)for(int i=0;i<n;i++)
#define rep(i,x,y) for(int i=x; i<y; i++)
#define rrep(i,x,y) for(int i=x; i>=y; i--)
#define vec vector<long long>
#define ys(f) f?cout<<"YES\n":cout<<"NO\n"
#define pii pair<int,int>
const string STRING_MAX(1000, '\xFF');
void _print(int t) { cout << t; }
void _print(double t) { cout << t; }
void _print(const string &s) { cout << s; }
void _print(char c) { cout << c; }
#ifndef ONLINE_JUDGE
#define debug(x)cout<<#x <<" ";_print(x);cout<<endl;
#else
#define debug(x)
#endif
 
template <class T> void _print(const vector<T>& v) { cout << "[ "; for (const T& elem : v) { _print(elem); cout << " "; } cout << "]"; }
template <class T> void _print(const set<T>& v) { cout << "[ "; for (const T& elem : v) { _print(elem); cout << " "; } cout << "]"; }
template <class T> void _print(const multiset<T>& v) { cout << "[ "; for (const T& elem : v) { _print(elem); cout << " "; } cout << "]"; }
template <class T, class V> void _print(const pair<T, V>& p) { cout << "{"; _print(p.first); cout << ","; _print(p.second); cout << "}"; }
template <class T, class V> void _print(const map<T, V>& v) { cout << "[ "; for (const auto& elem : v) { _print(elem); cout << " "; } cout << "]"; }
template <class T, class V> void _print(const vector<pair<T, V>>& v) { cout << "[ "; for (const auto& elem : v) { _print(elem); cout << " "; } cout << "]"; }
template <class T1, class T2> void _print(const vector<vector<pair<T1, T2>>>& v) { cout << "[ "; for (const auto& innerVec : v) { _print(innerVec); cout << " "; } cout << "]"; }
 
void _print(stack<int> s) { stack<int> temp; while (!s.empty()) { temp.push(s.top()); s.pop(); } cout << "[ "; while (!temp.empty()) { _print(temp.top()); cout << " "; temp.pop(); } cout << "]"; }
template <class T> void _print(stack<vector<T>> s) { stack<vector<T>> temp; while (!s.empty()) { temp.push(s.top()); s.pop(); } cout << "[ "; while (!temp.empty()) { _print(temp.top()); cout << " "; temp.pop(); } cout << "]"; }
 
void _print(queue<int> q) { queue<int> temp; while (!q.empty()) { temp.push(q.front()); q.pop(); } cout << "[ "; while (!temp.empty()) { _print(temp.front()); cout << " "; temp.pop(); } cout << "]"; }
template <class T> void _print(queue<vector<T>> q) { queue<vector<T>> temp; while (!q.empty()) { temp.push(q.front()); q.pop(); } cout << "[ "; while (!temp.empty()) { _print(temp.front()); cout << " "; temp.pop(); } cout << "]"; }
 
//----------------------------------------------------------------------------------------------//
int nCr(int N, int R) { if (R > N) return 0; if (R == 0 || R == N) return 1; R = std::min(R, N - R); int result = 1; for (int i = 1; i <= R; ++i) { result *= (N - R + i); result /= i; } return result; }
vector<string> split(string s) { vector<string> v; string ans; for (auto x : s) { if (x != ' ') { ans += x; } else { if (!ans.empty()) { v.emplace_back(ans); ans.clear(); } } } if (!ans.empty()) v.emplace_back(ans); return v; }
int gcd(int a, int b) { while (b != 0) { int temp = b; b = a % b; a = temp; } return a; }
int lcm(int a, int b) { return (a * b) / gcd(a, b); }
bool checkSorted(vector<int>& v, int n) { for (int i = 1; i < n; i++) { if (v[i] < v[i - 1]) return false; } return true; }
vec Rotate(vector<int>& v, int n) { vector<int> ans; ans.emplace_back(v[n - 1]); for (int i = 0; i < n - 1; i++) ans.emplace_back(v[i]); return ans; }
bool checkPrime(int a) { for (int i = 2; i * i <= a; i++) { if (a % i == 0) return false; } return true; }
int CEIL(int a,int b) { return (a+b-1)/b; }
void eraseOneOccurrence(multiset<int>& mset, int element) { auto it = mset.find(element); if (it != mset.end()) { mset.erase(it); } }
int kadane(vector<int>& v, int n) { int maxi = 0, sum = 0; for (int i = 0; i < n; i++) { sum += v[i]; if (sum < 0) sum = 0; maxi = max(maxi, sum); } return maxi; }
int modPow(int base, int exp, int mod) { int result = 1; while (exp > 0) { if (exp % 2 == 1) result = (result * base) % mod; base = (base * base) % mod; exp /= 2; } return result; }
int modDivide(int a, int b, int p) { return (a * modPow(b, p - 2, p)) % p; }
int binaryToDecimal(const std::string& binaryStr) { int decimalNumber = 0, base = 1; for (int i = binaryStr.length() - 1; i >= 0; --i) { if (binaryStr[i] == '1') decimalNumber += base; base *= 2; } return decimalNumber; }
double distance(double x, double y, double a, double b) { return sqrt((x - a) * (x - a) + (y - b) * (y - b)); }
auto print_with_precision = [](double x, int p) { cout << fixed << setprecision(p) << x << endl; };
int justSmaller(vector<int> v, int target){
    int a=lower_bound(v.begin(),v.end(),target)-v.begin();
    if(a==v.size()) return a-1;
    if(v[a]==target) return a;
    return a-1;
}
int MSB(int a) { return a > 0 ? (int)log2(a) + 1 : 0;}
bool valid(vector<vector<char>>& v,int i, int j, int n, int m){ return (i>=0 && j>=0 && i<n && j<m && v[i][j]=='x');}
int dx[4]={-1, 1, 0, 0}; int dy[4]={0, 0, -1, 1};
int dx1[8]={-1,1,0,0,-1,-1,1,1}; int dy1[8]={0,0,-1,1,-1,1,-1,1};
bool isPrime(int a){
    if(a==1) return 0;
    for(int i=2;i*i<=a;i++) if(a%i==0) return false; else return true;
}
//--------------------------------------------------------------------------------------//
struct node{
    int sum;//node would store sum,(state)
    node(){
        sum=0;
    }
};
node merge(node a, node b){
    node ans;
    ans.sum=a.sum+b.sum;
    return ans;//transition
}
vec arr; vector<node> seg;
void build(int i=0, int low=0, int high=arr.size()-1){
    if(low==high){
        //base case 
        seg[i].sum=arr[low];
        return;//leaf node is arr[low] only not arr[i]
    }
    int mid=(low+high)/2;
    build(2*i+1,low,mid);
    build(2*i+2,mid+1,high);
    seg[i]=merge(seg[2*i+1],seg[2*i+2]);
}
void update(int pos, int val,int i=0, int low=0, int high=arr.size()-1){
    //we would need base case, and a pruning statement, 
    //pruing statement is koi chutiyaap hojaye 
    //we do it in range (low,high) updating seg[pos]=val;
    if(pos<low || pos>high){
        return;//agar out of range: go out
    }
    if(low==high){
        seg[i].sum=val;
        return;
    }
    int mid=(low+high)/2;
    update(pos,val,2*i+1,low,mid);
    update(pos,val,2*i+2,mid+1,high);
    seg[i]=merge(seg[2*i+1],seg[2*i+2]);
}
node query(int l, int r, int i=0, int low=0, int high=arr.size()-1){
    if(high<l || r<low){
        return node();//no overlap
    }
    if(l<=low && high<=r){
        return seg[i];
    }
    int mid=(low+high)/2;
    node left=query(l,r,2*i+1,low,mid);
    node right=query(l,r,2*i+2,mid+1,high);
    return merge(left,right);
}
signed main(){
    fastio();
    int n,q; cin>>n>>q;
    arr.resize(n); seg.resize(4*n);
    ffor(n) cin>>arr[i];
    build();
    //cout<<endl;
    while(q--){
        int a; cin>>a;
        if(a==1){
            int b,c; cin>>b>>c;
            b--;
            update(b,c);
        }
        else{
            int l,r; cin>>l>>r;
            l--;r--;
            cout<<query(l,r).sum<<endl;
        }
    }
}
//-----------------------------------------------------------------------------------------
//imp baatien
//27) cycle in undirected: topo sort, cycle in directed: DSU
//23) max activities:sort end and start seperately, do 2 pointer if(a[i]<=b[j]) i++, ans++; else j++, ans--,keep updating maxi
//24) merge: output.back()[1]>=start of ith, output.back()[1]=max(of dono ke times),srot on start times
//25) 2D prefix: P[i][j]=P[i-1][j]+P[j-1][i]+a[i][j]-P[i-1][j-1]
//26) sum of [a..c][b...d] is P[c][d]-P[c][b-1]-P[a-1][d]+P[a-1][b-1]
//20) left shift can fail for numbers in int range, but int would not.
//21) area of tri=1/2|X3(Y2-Y1)+X1(Y3-Y2)+X2(Y3-Y1)|
//22) look if arr is permutation, it can help in many cases
//9) << is * and >> is /
//10) 1 to N mine XOR has a pattern, L to R ke liye 1 TO r mine se 1 to L kro 
//11) to check if a bit(j) is subset of i, do (i&j==j)
//12) for ith bit its (2<<i),do OR to set, do & to check(mask hi aana chahiye), do ~ krke & to unset 
//13)XOR of all subs is 0 
//14)inv of XOR is XOR.
//15) in bits q, if you want to max or minimise, tey to max/min the ith bit only.
//16) a set has next and prev with it, you can use prev(it) after taking the iterator
//17) min XOR of a pair in an array can be found by sorting it
//18) it should be notes that lower bound gives only first occ in case dups are present, so in this
//case you may implement your own algo
//19) a+b=(a^b) + 2(a&b) and a|b=a^b+(a&b)
//1)s+ rev(s)is always a palindrome
//2)har q mine TTFFF jaisa bana ke dekhlo
//3)sum[l:r] ke liye do prefix[r]-prefix[l-1];but if l==0 return prefix[r];
//4)is v[i] is small,think if we only need first/last index of an ocarrence.
//cause now we may be able to use brute force.
//5)say in a knapsack prblm,hume bol diya ki if you take the first ele,you cannot
//take the last,we can just keep 1 more dimension in our Dp(bool take),this is a key
//idea to just keep adding dimensions if u have prblms
//6) evy int can be written in from of sum of 2 primes
//7) there is always a prime bw 2 perfect sqs 
//8)Pythogorian triplet: n^2-m^2, 2nm and n^2+m^2
